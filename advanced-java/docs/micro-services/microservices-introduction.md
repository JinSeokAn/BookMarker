# 마이크로서비스

>  [마틴 파울러](https://martinfowler.com/) 의 웹사이트 [Microservices](https://martinfowler.com/articles/microservices.html) 에서 번역한 글입니다. 글의 길이가 길며, 읽기에 약간의 인내가 필요합니다.<br> 개인적인 수준이 제한되어 있어 부적절한 부분이 있을 수 있으니, 여러분의 지적을 부탁드립니다. 감사합니다.

최근 몇 년 동안 "마이크로서비스 아키텍처"라는 용어가 등장했습니다. 이는 소프트웨어 애플리케이션을 독립적으로 배포할 수 있는 여러 서비스 모음으로 설계하는 특정 방법을 설명합니다. 이 아키텍처 스타일에 대한 정확한 정의는 아직 없지만, 비즈니스 기능을 중심으로 한 조직, 자동 배포, 엔드포인트의 지능, 그리고 언어 및 데이터의 분산 제어 등에 대해 일부 공통 특성이 존재합니다.

"마이크로서비스" - 소프트웨어 아키텍처의 붐비는 거리에서 또 다른 신조어입니다. 우리의 자연스러운 경향은 그것을 가볍게 보는 것이지만, 이 용어는 점점 더 매력적인 소프트웨어 시스템 스타일을 설명합니다. 최근 몇 년 동안, 우리는 이러한 스타일을 사용한 많은 프로젝트를 보았으며, 지금까지의 결과는 모두 긍정적이어서, ThoughtWorks의 많은 동료들이 기업 애플리케이션을 구축하는 데 디폴트 스타일이 되었습니다. 그러나 아쉽게도 이 스타일을 개요하거나 어떻게 구현할 수 있는지에 대한 정보는 많지 않습니다.

간단히 말해서, 마이크로서비스 아키텍처 스타일은 단일 애플리케이션을 개발하는 방법으로, 각 서비스는 자체 프로세스에서 실행되며, 보통 HTTP 리소스 API와 같은 가벼운 메커니즘을 통해 통신합니다. 이러한 서비스는 비즈니스 기능을 중심으로 구축되며, 완전 자동화된 배치 메커니즘을 통해 독립적으로 배포할 수 있습니다. 이러한 서비스는 최소한의 중앙 관리를 공유하며, 서로 다른 프로그래밍 언어로 작성되고, 다양한 데이터 저장 기술을 사용할 수 있습니다.

마이크로서비스 스타일을 설명하기 전에, 그것을 모놀리식(monolithic) 스타일과 비교하는 것이 유용합니다: 단일 애플리케이션은 단일 단위로 구축됩니다. 기업 애플리케이션은 일반적으로 세 부분으로 구성됩니다: 클라이언트 사용자 인터페이스(사용자 기계에서 실행되는 HTML 페이지와 Javascript로 구성됨), 데이터베이스(일반적으로 관계형 데이터베이스에서 관리되는 많은 테이블로 구성됨), 서버 측 애플리케이션. 서버 측 애플리케이션은 HTTP 요청을 처리하고, 일부 로직을 수행하고, 데이터베이스에서 데이터를 검색 및 업데이트하고, 데이터를 선택하여 브라우저로 보낼 HTML 뷰에 채웁니다. 이 서버 측 애플리케이션은 하나의 전체입니다 - 하나의 로직 실행 파일입니다. 시스템에 대한 어떤 변경이든 서버 측 애플리케이션의 새 버전을 빌드하고 배포하는 것을 포함합니다.

이런 식으로 단일 서버를 구축하는 것은 이러한 시스템을 구축하는 자연스러운 방법입니다. 요청을 처리하는 모든 로직이 하나의 프로세스에서 실행되므로, 언어의 기본 기능을 사용하여 애플리케이션을 클래스, 함수 및 네임스페이스로 나눌 수 있습니다. 애플리케이션을 개발자의 노트북에서 실행하고 테스트할 수 있으며, 배포 파이프라인을 사용하여 프로그램에 대한 변경 사항이 적절하게 테스트되고 생산 환경에 배포되도록 할 수 있습니다. 부하 분산기 뒤에서 많은 인스턴스를 실행하여 전체 블록을 수평 확장할 수 있습니다.

단일 애플리케이션은 성공할 수 있지만, 점점 더 많은 사람들이 그것들에 대해 불만을 가지고 있습니다 - 특히 클라우드로 더 많은 애플리케이션을 배포할 때입니다. 변경 주기가 함께 묶여 있습니다 - 애플리케이션의 작은 부분만 변경되더라도 전체 단일 애플리케이션을 다시 빌드하고 배포해야 합니다. 시간이 지남에 따라, 모듈화 구조를 유지하기가 점점 더 어려워지며, 특정 모듈에서만 영향을 미쳐야 하는 변경 사항이 더 어렵습니다. 시스템을 확장할 때, 전체 애플리케이션을 확장해야 하며, 시스템에서 더 많은 리소스가 필요한 부분만 확장할 수는 없습니다.

![sketch](./images/sketch.png)

이러한 불만이 마이크로서비스 아키텍처 스타일로 이어집니다: 애플리케이션을 서비스 모음으로 구축합니다. 서비스가 독립적으로 배포될 수 있고, 독립적으로 확장될 수 있다는 사실 외에도, 각 서비스는 다른 프로그래밍 언어로 작성될 수 있도록 견고한 모듈 경계를 제공합니다. 그들은 또한 서로 다른 팀에 의해 관리될 수 있습니다.

우리는 마이크로서비스 스타일이 새롭거나 혁신적이라고 생각하지 않습니다. 그 뿌리는 적어도 유닉스의 설계 원칙까지 거슬러 올라갈 수 있습니다. 그러나 우리는 마이크로서비스 아키텍처에 대해 충분히 많은 사람들이 생각하지 않는다고 믿습니다. 만약 사용된다면, 많은 소프트웨어의 개발이 개선될 것입니다.



## 마이크로서비스 아키텍처의 특성

마이크로서비스 아키텍처 스타일에 대한 공식적인 정의는 없을 수 있지만, 우리는 이 스타일을 따르는 아키텍처에서 보통 가지고 있는 몇 가지 공통 특성을 설명할 수 있습니다. 모든 정의에서 공통 특성을 개요화하는 것처럼, 모든 마이크로서비스 아키텍처가 모든 특성을 가지고 있는 것은 아니지만, 우리는 대부분의 마이크로서비스 아키텍처가 대부분의 특성을 가지고 있을 것으로 기대합니다. 비록 우리 저자들이 이 비교적 느슨한 커뮤니티의 활동적인 회원이긴 하지만, 우리의 의도는 우리 둘 모두가 자신과 자신이 알고 있는 팀의 작업에서 본 것을 설명하는 것입니다. 특히 우리는 일부 관련 정의를 만드는 것이 아닙니다.

### 서비스를 통한 구성요소화

우리가 소프트웨어 업계에 있었던 한, 시스템을 구성요소들을 함께 결합하여 구축하는 것을 원했습니다. 지난 수십 년 동안, 우리는 대부분의 언어 플랫폼에서 공용 소프트웨어 라이브러리가 크게 발전했음을 보았습니다.

구성요소에 대해 이야기할 때, 우리는 정의의 문제에 부딪힙니다. 구성요소란 무엇인가? 우리의 정의는 독립적으로 교체하고 업그레이드할 수 있는 소프트웨어 단위입니다.

마이크로서비스 아키텍처는 또한 소프트웨어 라이브러리를 사용하지만, 소프트웨어를 구성요소화하는 주요 방법은 여러 서비스로 분할하는 것입니다. 라이브러리를 프로그램에 링크하고 메모리 내 함수 호출을 사용하여 호출하는 구성요소로 정의하고, 서비스는 웹 서비스 요청이나 원격 프로시저 호출과 같은 메커니즘을 통해 통신하는 프로세스 외부 구성요소로 정의합니다. (이것은 이 글에서 사용하는 "서비스"와 다른 개념입니다. 불행히도 서비스에는 두 가지 의미가 있고, 우리는 이 다의어를 살아야 합니다.)

서비스를 구성요소로 사용하는 주요 이유 중 하나는 서비스가 독립적으로 배포될 수 있다는 것입니다. 단일 프로세스 내의 여러 라이브러리로 구성된 애플리케이션을 가지고 있다면, 어떤 구성요소의 변경도 전체 애플리케이션의 재배포를 포함합니다. 그러나 애플리케이션이 여러 서비스로 나뉘어져 있다면, 단일 서비스의 변경은 해당 서비스만 재배포하면 됩니다. 물론 이것도 절대적이지는 않습니다. 일부 서비스 인터페이스의 수정은 여러 서비스 간의 조정 변경을 요구할 수 있지만, 좋은 마이크로서비스 아키텍처의 목적은 서비스 경계의 응집력과 서비스 프로토콜의 진화 메커니즘을 통해 이러한 조정 변경을 최소화하는 것입니다.

서비스를 구성요소로 사용하는 또 다른 결과는 더 명확한 구성요소 인터페이스입니다. 대부분의 언어에는 명시적으로 게시된 인터페이스를 정의하는 좋은 메커니즘이 없습니다. 보통 문서와 규칙을 사용하여 클라이언트가 구성요소의 캡슐화를 깨뜨리지 않도록 하는 것이 전부이며, 이로 인해 구성요소 간에 너무 밀접하게 결합됩니다. 명시적 원격 호출 메커니즘을 사용함으로써 서비스는 이러한 상황을 더 쉽게 피할 수 있습니다.

이렇게 서비스를 사용하는 것은 단점이 있습니다. 원격 호출은 프로세스 내 호출보다 비용이 많이 들며, 원격 API는 더 광범위하게 설계되어야 하며, 일반적으로 사용하기가 더 어렵습니다. 구성요소 간의 책임 할당을 변경해야 하는 경우, 프로세스 경계를 넘나드는 구성요소 동작의 변경이 더 어려워집니다.

대략적으로, 우리는 각 서비스를 개별 실행 프로세스로 매핑할 수 있지만, 이것은 단지 대략적인 것일 뿐입니다. 하나의 서비스는 항상 함께 개발되고 배포되는 여러 프로세스를 포함할 수 있습니다. 예를 들어, 애플리케이션의 프로세스와 해당 서비스만 사용하는 데이터베이스 같은 것입니다.

### 비즈니스 기능을 중심으로 조직화

큰 애플리케이션을 여러 부분으로 나눌 때, 관리자들은 종종 기술적인 측면에 중점을 두어 UI 팀, 서버 측 로직 팀, 데이터베이스 팀으로 나눕니다. 이러한 방식으로 팀을 나눌 때, 심지어 간단한 변경도 여러 팀 간의 프로젝트에 시간과 예산 승인이 필요할 수 있습니다. 현명한 팀은 이를 최적화하기 위해 "두 가지 나쁜 것 중 덜 나쁜 것을 선택"하는 방식을 사용합니다 - 그들은 강제로 로직을 자신들이 접근할 수 있는 어떤 애플리케이션에도 적용합니다. 즉, 로직이 어디에나 있습니다. 이것은 컨웨이의 법칙의 한 예입니다.

> 어떤 설계 시스템(넓은 의미로)이든, 그 조직은 설계의 구조가 조직의 통신 구조의 복제본이 되도록 하는 시스템을 생성합니다.<br> —— 멜빈 컨웨이, 1967

![conways-law](./images/conways-law.png)

마이크로서비스는 시스템을 여러 서비스로 나누는 다른 방법을 채택합니다. 그것은 비즈니스 기능을 중심으로 시스템을 나눕니다. 이러한 서비스는 해당 비즈니스 영역에 대한 광범위한 소프트웨어 구현을 제공하며, 사용자 인터페이스, 지속성 저장소, 그리고 모든 외부 협업을 포함합니다. 따라서 팀은 기능을 가로질러 필요한 모든 기술을 포함하는 교차 기능 팀입니다.

![PreferFunctionalStaffOrganization](./images/PreferFunctionalStaffOrganization.png)

영국의 [www.comparethemarket.com](http://www.comparethemarket.com/) 은 이러한 방식으로 조직된 회사의 좋은 예입니다. 교차 기능 팀은 각 제품을 구축하고 운영하며, 각 제품은 여러 개의 독립적인 서비스로 나뉘며, 이들은 메시지 버스를 통해 서로 통신합니다.

큰 단일 애플리케이션도 비즈니스 기능을 중심으로 모듈화될 수 있지만, 이는 드문 경우입니다. 물론, 우리는 단일 애플리케이션을 구축하는 대규모 팀이 비즈니스 라인을 중심으로 자신을 분할하기를 권장합니다. 여기에서 우리가 보는 주요 문제는 그들이 너무 많은 컨텍스트를 중심으로 조직된다는 것입니다. 단일 애플리케이션을 통해 모듈 경계를 넘나들 경우, 팀 구성원이 이를 단기 기억에 유지하기 어렵습니다. 또한, 모듈화 생산라인을 유지하는 데 많은 규칙이 필요합니다. 서비스 구성요소가 요구하는 더 명확한 분리는 이러한 팀 경계를 명확하고 유지하기 쉽게 만듭니다.

### 제품이지 프로젝트다

우리가 보는 대부분의 애플리케이션 개발 작업은 이러한 프로젝트 패턴을 사용합니다: 소프트웨어를 제공하는 것이 목표이며, 그런 다음 완료되면 작업이 완료됩니다. 일단 완료되면, 소프트웨어는 유지보수 조직으로 이전되고, 프로젝트 팀은 해체됩니다.

마이크로서비스 지지자들은 이러한 패턴을 피하려고 합니다. 대신, 팀이 제품의 전체 수명 주기에 대해 책임을 져야 한다고 생각합니다. 이 개념의 일반적인 표현은 아마존의 [“당신이 만들었다면, 당신이 운영한다”](https://queue.acm.org/detail.cfm?id=1142065) 일 것입니다. 개발 팀은 생산 중인 소프트웨어에 대해 전적으로 책임을 져야 하며, 개발자는 소프트웨어가 생산 환경에서 어떻게 작동하는지 자주 접하게 되며, 사용자와의 연결도 증가합니다. 왜냐하면 그들은 적어도 일부 지원 작업을 수행해야 하기 때문입니다.

비즈니스 기능과의 연관성은 제품 마인드셋과 밀접하게 연결되어 있습니다. 소프트웨어가 사용자가 비즈니스 기능을 향상시키는 방법에 지속적으로 집중하는 것이 중요합니다. 소프트웨어를 일련의 기능으로 보는 것이 아니라 말이죠.

서비스를 작은 단위로 나누면 서비스 개발자와 사용자 간에 개인적인 관계를 구축하기 더 쉽습니다.

### 스마트 엔드포인트와 덤브 파이프

다른 프로세스 간에 통신을 설정할 때, 우리는 통신 메커니즘 자체에 많은 지능을 넣는 제품과 접근 방식을 많이 보았습니다. 좋은 예는 엔터프라이즈 서비스 버스(ESB)로, ESB 제품은 메시지 라우팅, 오케스트레이션, 변환 및 비즈니스 규칙 적용과 같은 복잡한 기능을 포함하는 도구입니다.

마이크로서비스 커뮤니티는 다른 접근 방식을 선호합니다: 스마트 엔드포인트와 덤브 파이프. 마이크로서비스로 구축된 애플리케이션의 목표는 가능한 한 해제되고 가능한 한 응집력 있게 만드는 것입니다. 그들은 클래식 유닉스 철학의 필터처럼 자신의 도메인 로직에 따라 요청을 받고 적절한 로직을 적용하고 응답을 생성합니다. REST 스타일의 프로토콜을 사용하여 조합하는 것이 좋습니다. 비슷한 복잡한 프로토콜 대신에 WS-Choreography, BPEL 또는 중앙 오케스트레이션과 같은 것을 사용하는 것이 좋습니다.

가장 일반적으로 사용되는 두 가지 프로토콜은 HTTP 요청-응답 리소스 API와 경량 메시지 전달입니다. 첫 번째 프로토콜에 대한 가장 좋은 설명은

> 웹 자체가 되는 것이지, 웹 뒤에 숨는 것이 아닙니다. <br> ——[Ian Robinson](http://www.amazon.com/gp/product/0596805829?ie=UTF8&tag=martinfowlerc-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0596805829)

마이크로서비스 팀이 사용하는 규칙과 프로토콜은 웹을 구축하는 규칙과 프로토콜입니다(큰 부분에서는 유닉스의 것입니다). 개발자와 운영자의 관점에서 볼 때, 일반적으로 사용되는 리소스는 캐시하기 쉽습니다.

두 번째로 자주 사용되는 방법은 경량 메시지 버스를 통해 메시지를 전달하는 것입니다. 선택된 인프라는 RabbitMQ나 ZeroMQ와 같은 간단한 구현으로, 덤브한(메시지 라우터 역할만 하는) 것입니다. 서비스에서 생성되고 소비되는 많은 메시지의 지능은 다양한 엔드포인트, 즉 다양한 서비스에 존재합니다.

단일 애플리케이션에서, 구성요소들은 같은 프로세스 내에서 실행되며, 메소드 호출이나 함수 호출을 통해 서로 통신합니다. 단일체를 마이크로서비스로 변환할 때, 통신 패턴이 변경되는 것이 가장 큰 문제입니다. 단순한 RPC로 프로세스 내 호출을 변환하는 것은 자주 통신하고 성능이 나쁘기 때문에 어리석은 전환이 될 수 있습니다. 대신, 더 광범위한 통신으로 더 세밀한 통신을 대체해야 합니다.

### 분산된 거버넌스

중앙 집중식 거버넌스의 결과 중 하나는 단일 기술 플랫폼 표준화의 발전 경향입니다. 경험적으로, 이러한 접근 방식은 축소되고 있습니다 - 모든 문제가 못이라면, 모든 문제에 대한 해결책은 망치가 아닙니다. 우리는 올바른 도구를 사용하여 작업을 완료하는 것을 선호합니다. 단일 애플리케이션에서는 언어의 장점을 일정 부분 활용할 수 있지만, 이는 드문 경우입니다.

컴포넌트를 서비스로 분리하면 서비스를 구축할 때 선택권이 생깁니다. Node.js를 사용하여 간단한 보고서 페이지를 개발하고 싶으세요? 진행하세요. C++로 특히 빠른 거의 실시간 컴포넌트를 구현하고 싶으세요? 훌륭합니다. 구성요소의 읽기 작업 데이터에 더 적합한 다른 스타일의 데이터베이스로 전환하고 싶으세요? 우리는 그것을 재구성할 기술을 가지고 있습니다.

물론, 당신이 무엇인가를 할 수 있다고 해서 그것을 해야 한다는 의미는 아닙니다. 하지만 이러한 방식으로 시스템을 분할함으로써 선택할 수 있습니다.

팀이 마이크로서비스를 구축할 때, 그들은 거버넌스에 접근하는 방식도 다릅니다. 그들은 유용한 도구를 생산하는 아이디어를 선호하며, 종이에 쓰인 표준보다는 다른 개발자가 비슷한 문제를 해결할 수 있도록 도와줍니다. 때때로, 이러한 도구는 실제 구현에서 성장하고 더 넓은 그룹과 공유되며, 하지만 내부 오픈 소스 모델을 사용하지 않고도 완전히 사용됩니다. 이제 git과 github가 사실상의 버전 제어 시스템으로 자리 잡았으며, 내부 오픈 소스 실천도 점점 더 일반적이 되고 있습니다.

Netflix는 이러한 철학을 따르는 좋은 예입니다. 특히, 시장에서 검증된 코드의 유용한 라이브러리를 공유함으로써 다른 개발자가 유사한 방식으로 유사한 문제를 해결하도록 동기를 부여하는 동시에 다른 접근 방식의 문을 열어줍니다. 공유 라이브러리는 일반적으로 데이터 저장, 프로세스 간 통신 및 우리가 곧 논의할 인프라 자동화와 같은 공통 문제에 중점을 둡니다.

마이크로서비스 커뮤니티에게 오버헤드는 특히 매력적이지 않습니다. 이것은 커뮤니티가 서비스 계약을 가볍게 여기는 것을 의미하지는 않습니다. 정반대입니다. 왜냐하면 그들은 더 많은 계약을 가지고 있기 때문입니다. 그들은 단지 이러한 계약을 관리하는 다른 방법을 찾고 있습니다. [Tolerant Reader](https://martinfowler.com/bliki/TolerantReader.html) 와 [Consumer-Driven Contracts](https://martinfowler.com/articles/consumerDrivenContracts.html) 와 같은 패턴은 일반적으로 마이크로서비스에서 사용됩니다. 이러한 도움으로 서비스 계약이 독립적으로 진화할 수 있습니다. 소비자 주도 계약을 빌드의 일부로 실행함으로써, 서비스가 제대로 작동하는지에 대한 더 빠른 피드백과 더 많은 신뢰를 제공합니다. 사실, 우리가 아는 호주의 한 팀은 소비자 주도 계약 패턴을 사용하여 새로운 비즈니스를 구축하고 있습니다. 그들은 간단한 도구를 사용하여 서비스 계약을 정의합니다. 이것은 자동 빌드의 일부가 되었으며, 심지어 새로운 서비스의 코드가 아직 작성되지 않았습니다. 서비스는 계약을 충족할 때만 생성됩니다 - 새로운 소프트웨어를 구축할 때 "YAGNI" 딜레마를 피하는 우아한 방법입니다. 이러한 기술과 도구를 중심으로 성장하는 것은 서비스 간의 임시 결합을 줄임으로써 중앙 계약 관리의 필요성을 제한합니다.

아마도 분산 거버넌스의 궁극적인 표현은 아마존의 유명한 build it/run it 철학일 것입니다. 팀은 그들이 만든 소프트웨어의 모든 측면에 대해 책임을 져야 하며, 7*24시간 운영해야 합니다. 이러한 수준의 책임 분배는 절대적으로 비정형적이지만, 우리는 점점 더 많은 회사가 개발 팀에 더 많은 책임을 부여하는 것을 보고 있습니다. Netflix는 이러한 철학을 채택한 또 다른 회사입니다. 개발자가 쓴 코드를 운영하는 것은 분명히 강력한 동기 부여가 됩니다. 새벽 3시에 호출기로 깨어나는 것은 코드를 작성할 때 품질에 대해 생각하게 만드는 강력한 동기입니다. 이것은 가능한 한 멀리 전통적인 중앙 집중식 거버넌스 모델에서 벗어나려는 몇 가지 생각입니다.

### 분산 데이터 관리

데이터 관리의 분산화는 여러 가지 다른 방식으로 나타납니다. 가장 추상적인 수준에서, 이것은 시스템 간에 다른 세계의 개념 모델이 존재한다는 것을 의미합니다. 큰 기업을 통합할 때, 판매 관점에서의 고객은 지원 관점에서의 고객과 다를 수 있습니다. 이것은 흔한 문제입니다. 판매 관점에서의 고객에 대한 몇 가지 사항은 지원 관점에서는 나타나지 않을 수 있습니다. 실제로, 그들은 서로 다른 속성을 가질 수 있고(더 나쁜 것은) 공통 속성이 의미상으로 미묘하게 다를 수 있습니다.

이 문제는 애플리케이션 간에 발생할 수 있지만, 애플리케이션 내부에서도 발생할 수 있습니다. 특히 애플리케이션을 분리된 구성요소로 나눌 때입니다. 유용한 사고 방식은 도메인 주도 설계(Domain-Driven Design, DDD)의 아이디어인[유계 컨텍스트](http://martinfowler.com/bliki/BoundedContext.html)(Bounded Context)입니다. DDD는 복잡한 도메인을 여러 유계 컨텍스트로 나누고 그 사이의 관계를 매핑합니다. 이 프로세스는 모놀리식 아키텍처와 마이크로서비스 아키텍처 모두에 유용하지만, 서비스와 컨텍스트 경계 사이에는 자연스러운 상관 관계가 있으며, 경계는 분리를 명확하게 하고 강화하는 데 도움이 됩니다.

개념 모델의 분산화 결정과 마찬가지로, 마이크로서비스는 데이터 저장 결정을 분산화합니다. 단일 애플리케이션은 일반적으로 지속성 저장을 위해 단일 논리 데이터베이스를 선호하지만, 기업은 종종 일련의 애플리케이션을 공유하는 단일 데이터베이스를 선호합니다. 이러한 결정은 공급업체 라이선스 모델에 의해 주도됩니다. 마이크로서비스는 각 서비스가 자체 데이터베이스를 관리하도록 선호합니다. 같은 데이터베이스 기술의 서로 다른 인스턴스일 수도 있고, 완전히 다른 데이터베이스 시스템일 수도 있습니다. 이것은[폴리글랏 지속성](https://martinfowler.com/bliki/PolyglotPersistence.html)(Polyglot Persistence) 입니다. 당신은 단일 애플리케이션에서 폴리글랏 지속성을 사용할 수 있지만, 서비스에서 더 자주 나타납니다.

![decentralised-data](./images/decentralised-data.png)

마이크로서비스 간의 데이터에 대해, 분산화된 책임은 업그레이드를 관리하는 방법에 영향을 미칩니다. 일반적으로 사용되는 방법은 여러 리소스를 업데이트할 때 트랜잭션을 사용하여 일관성을 보장하는 것입니다. 이 방법은 단일체에서 자주 사용됩니다.

이러한 방식으로 트랜잭션을 사용하면 일관성이 도움이 되지만, 여러 서비스를 가로질러 복잡성이 증가합니다. 분산 트랜잭션은 구현하기가 악명 높으므로, 마이크로서비스 아키텍처는 [서비스 간의 트랜잭션 없는 협업](http://www.eaipatterns.com/ramblings/18_starbucks.html)，을 강조하며, 일관성은 종종 최종 일관성이며, 문제 처리는 보상 작업을 통해 이루어집니다.

많은 개발 팀에게, 이러한 방식으로 불일치를 관리하는 것은 새로운 도전입니다. 그러나 이것은 일반적으로 비즈니스 관행과 일치합니다. 비즈니스는 빠른 대응을 위해 일정 수준의 불일치를 처리하며, 동시에 문제를 처리하기 위한 일부 유형의 역전 과정을 가지고 있습니다. 이러한 트레이드오프는 오류 수정 비용이 더 큰 일관성 손실 비용보다 작은 경우 가치가 있습니다.

### 인프라 자동화

지난 몇 년 동안 기반 구조 자동화 기술은 크게 변화했습니다. 특히 클라우드와 AWS의 발전은 마이크로서비스를 구축, 배포 및 운영하는 복잡성을 크게 줄였습니다.

마이크로서비스로 구축된 많은 제품이나 시스템은 지속적인 전달 및 지속적 통합 경험이 풍부한 팀에 의해 구축됩니다. 이러한 방식으로 소프트웨어를 구축하는 팀은 인프라 자동화 기술을 광범위하게 사용합니다. 아래에 표시된 빌드 파이프라인과 같습니다.

![basic-pipeline](./images/basic-pipeline.png)

이것은 지속적인 전달에 관한 글이 아니기 때문에, 우리는 여기에서 지속적인 전달의 몇 가지 핵심 특성에만 초점을 맞출 것입니다. 우리가 소프트웨어가 정상적으로 작동한다는 것에 대해 가능한 한 많은 확신을 가지고 있기를 원하기 때문에, 우리는 많은 <b>자동화된 테스트</b>를 수행합니다. 소프트웨어가 프로모션을 받아 파이프라인을 "푸시"할 수 있으려면, 새로운 환경에서 소프트웨어에 대한 <b>자동화된 배포</b>가 필요합니다.

단일 애플리케이션은 이러한 환경을 통해 즐겁게 구축, 테스트 및 푸시할 수 있습니다. 사실, 일단 당신이 단일체에 대한 전체적인 생산 자동화에 투자하면, 더 많은 애플리케이션을 배포하는 것이 그리 두렵지 않습니다. 지속적인 전달의 목표 중 하나는 "배포"를 "지루한" 작업으로 만드는 것이므로, 한 개든 세 개든 애플리케이션을 배포하는 것이 "지루"하다면 걱정할 것이 없습니다.

우리는 여기서 조금 불성실합니다. 물론 더 복잡한 토폴로지에서 더 많은 서비스를 배포하는 것은 단일 모놀리식 애플리케이션을 배포하는 것보다 더 어렵습니다. 다행히도, 패턴은 이 복잡성을 줄입니다 - 도구에 대한 투자는 여전히 필수입니다.

![micro-deployment](./images/micro-deployment.png)

### 실패에 대비한 설계

서비스를 구성요소로 사용한다는 것은 애플리케이션이 서비스의 실패를 용인할 수 있도록 설계해야 함을 의미합니다. 서비스 제공자가 사용할 수 없는 경우, 모든 서비스 호출이 실패할 수 있으며, 클라이언트는 가능한 한 우아하게 반응해야 합니다. 이것은 추가 복잡성을 도입하며, 이로 인해 애플리케이션이 어떻게 설계되어야 하는지 고려해야 합니다. 결과적으로, 마이크로서비스 팀은 서비스 실패가 사용자 경험에 어떤 영향을 미치는지에 대해 지속적으로 반영합니다. Netflix의 [Simian Army](https://github.com/Netflix/SimianArmy) 는 작업일에 서비스 또는 데이터 센터의 실패를 유발하여 애플리케이션의 복원력과 모니터링 기능을 테스트할 수 있습니다.

생산 환경에서 이러한 자동화된 테스트는 대부분의 운영 팀이 설레는 일이 될 것입니다. 이것은 모놀리식 아키텍처 스타일에서 고급 모니터링 시스템을 구축할 수 없다는 것을 의미하지는 않습니다. 사실, 그들도 그렇게 해야 합니다. 차이점은 서로 다른 프로세스에서 실행되는 서비스가 언제 연결이 끊어지는지 알아야 한다는 것입니다. 동일한 프로세스 내에서 라이브러리 간에 이러한 투명성은 그다지 유용하지 않습니다.

마이크로서비스 팀은 각 서비스에 대한 복잡한 모니터링 및 로깅을 보고 싶어합니다. 예를 들어, "실행/다운" 상태를 보여주는 대시보드와 다양한 운영 및 비즈니스 관련 지표가 있습니다. 또한, 서킷 브레이커 상태, 현재 처리량 및 지연 시간에 대한 자세한 정보도 우리가 작업 중에 자주 만나는 다른 예입니다.

### 설계 진화

마이크로서비스 실천자들은 일반적으로 진화적 설계 배경을 가지고 있으며, 서비스 분해를 애플리케이션 개발자가 애플리케이션 내의 변경을 제어할 수 있도록 하는 또 다른 도구로 보고 있습니다. 변경 제어는 필연적으로 변경 속도를 늦추지 않습니다. 올바른 태도와 도구의 도움으로, 소프트웨어에 대한 빈번하고 신속하며 잘 제어된 변경을 수행할 수 있습니다.

소프트웨어 시스템을 구성요소로 분해할 때마다, 어떻게 분해할지에 대한 결정을 내려야 합니다. 애플리케이션을 어떻게 분해해야 하는가에 대한 우리의 원칙은 무엇인가? 구성요소의 핵심 속성은 독립적으로 교체 및 업그레이드 가능한 것입니다. 이것은 우리가 이러한 지점을 찾고자 하는 것이며, 구성요소를 다시 작성하는 데 영향을 미치지 않고 교체할 수 있는 방법을 상상합니다. 실제로, 많은 마이크로서비스 팀은 많은 서비스가 장기적으로 진화하기보다는 폐기될 것으로 명시적으로 기대합니다.

Guardian 웹사이트는 단일 애플리케이션으로 설계되고 구축된 좋은 예입니다. 하지만 그들은 마이크로서비스 방향으로 진화하고 있습니다. 원래의 단일체 시스템은 여전히 사이트의 핵심이지만, 그들은 새로운 기능을 추가하기 위해 몇 가지 마이크로서비스 API를 구축하는 것을 선호합니다. 이러한 접근 방식은 본질적으로 일시적인 기능에 특히 유용합니다. 예를 들어, 스포츠 이벤트 전용 페이지를 처리합니다. 사이트의 이 부분은 신속하게 개발 언어로 빠르게 조합되어 이벤트가 끝나자마자 즉시 폐기될 수 있습니다. 우리는 금융 기관에서 비슷한 방식을 보았으며, 시장 기회에 대한 새로운 서비스를 추가하고 몇 달 또는 몇 주 후에 폐기합니다.

이러한 가치를 강조하는 것은 모듈화 설계의 일반적인 원칙, 즉 변화 패턴을 통해 모듈화를 구동하는 특정 사례입니다. 동시에 변화하는 것들을 같은 모듈에 넣는 것이 좋습니다. 시스템에서 거의 변화가 없는 모듈은 현재 많은 변화를 겪고 있는 시스템의 다른 서비스와는 다른 서비스에 있어야 합니다. 두 서비스를 반복해서 변경해야 한다면, 그것들은 합쳐져야 합니다.

서비스를 사용하여 구성요소를 분리하면 더 세밀한 출시 일정을 추가할 수 있는 기회를 제공합니다. 단일체의 경우, 어떤 변경 사항이든 전체 애플리케이션을 완전히 빌드하고 배포해야 합니다. 그러나 마이크로서비스를 사용하면 수정한 서비스만 다시 배포하면 됩니다. 단점은 서비스의 변경이 소비자를 방해할 수 있다는 것입니다. 전통적인 통합 접근 방식은 버전 관리를 사용하여 이 문제를 해결하려고 시도합니다. 하지만 마이크로서비스 세계에서는 가능한 한 버전 관리를 최후의 수단으로만 사용합니다. 서비스가 서비스 제공자의 변경에 대해 가능한 한 관대하게 설계되도록 함으로써 버전 관리의 필요성을 피할 수 있습니다.

## 마이크로서비스가 미래인가?

우리가 이 글을 쓰는 주된 목적은 마이크로서비스의 주요 아이디어와 원칙을 설명하는 것입니다. 이 시간을 들여 이것을 하는 것으로, 우리는 분명히 마이크로서비스 아키텍처 스타일이 중요한 아이디어라고 생각하며, 기업 시스템 개발 시 심각하게 고려할 가치가 있다고 생각합니다. 우리는 최근 이 방식으로 몇 가지 시스템을 구축했으며, 다른 팀도 이 스타일을 좋아한다는 것을 알고 있습니다.

우리는 일부 선구자들이 이 아키텍처 스타일을 개척했다고 생각합니다. 여기에는 아마존, 넷플릭스, 영국 가디언, 영국 정부 디지털 서비스, realestate.com.au, Forward, comparethemarket.com이 포함됩니다. 2013년 기술 회의에서는 이러한 회사들의 예시가 많이 있었으며, 이러한 회사들은 마이크로서비스로 분류될 수 있는 방식으로 전환하고 있습니다. 또한, 오랫동안 마이크로서비스라고 부르지 않았지만, 우리가 마이크로서비스라고 부르는 것을 하고 있던 많은 조직이 있습니다. (이것은 종종 SOA로 표시됩니다 - 비록 우리가 말했듯이, SOA에는 많은 상충되는 형태가 있습니다.)

그러나, 이러한 긍정적인 경험에도 불구하고, 우리는 마이크로서비스가 소프트웨어 아키텍처의 미래 방향이라고 확신할 수 없습니다. 지금까지 우리의 경험은 전체 애플리케이션과 비교했을 때 긍정적이지만, 우리는 충분한 시간이 지나지 않아 완전한 판단을 내릴 수 없다는 것을 인식합니다.

일반적으로, 아키텍처 결정의 진정한 효과는 그 결정이 내려진 지 몇 년이 지난 후에야 진정으로 나타납니다. 우리는 모듈화에 대한 강한 열망을 가진 뛰어난 팀에 의해 수행된 몇몇 프로젝트를 보았고, 결국에는 단일체를 구축하고 몇 년 후에 썩어가는 것을 보았습니다. 많은 사람들이 마이크로서비스를 사용하면 이러한 썩음이 발생하지 않을 것이라고 생각할 수 있습니다. 왜냐하면 서비스의 경계가 명확하고 쉽게 엉망이 되기 어렵기 때문입니다. 그러나 충분한 시간 동안 다양한 시스템을 보지 않고서는 우리는 마이크로서비스 아키텍처가 얼마나 성숙한지 정말로 평가할 수 없습니다.

어떤 사람들은 마이크로서비스가 결코 성숙하지 않을 것이라고 생각할 만한 이유가 있습니다. 이것은 확실히 이유가 있습니다. 구성요소화에 대한 모든 작업의 성공 여부는 소프트웨어와 구성요소 간의 적합도에 달려 있습니다. 어디에 구성요소의 경계가 있어야 하는지 정확하게 파악하는 것은 어려운 작업입니다. 진화적 설계는 경계의 정확한 위치를 파악하기 어렵다는 것을 인정하며, 그래서 그것은 경계를 재구성하기 쉽게 만드는 데 초점을 맞춥니다. 그러나 구성요소가 원격 통신을 하는 서비스가 되면, 단일 프로세스 내에서 소프트웨어 라이브러리 간에 호출을 하는 것보다 재구성이 더 어려워집니다. 서비스 경계를 가로질러 코드를 이동하는 것이 어렵습니다. 인터페이스의 모든 변경은 참여자 간에 조정되어야 합니다. 후방 호환성 레이어도 추가되어야 합니다. 테스트도 더 복잡해집니다.

또 다른 문제는 구성요소 간의 연결이 깔끔하게 조합되지 않으면 수행된 모든 작업이 단순히 구성요소 내의 복잡성을 구성요소 간의 연결로 이동시키는 것일 뿐이라는 것입니다. 이렇게 하면 복잡성이 이사를 가는 것이 아니라, 더 이상 명확하지 않고 제어하기 어려운 경계로 옮겨집니다. 구성요소 내부의 작은 단순한 구성요소를 관찰할 때, 사람들은 일이 더 나아졌다고 쉽게 생각할 수 있지만, 서비스 간의 혼란스러운 연결을 무시합니다.

마지막으로, 팀 기술의 요소가 있습니다. 새로운 기술은 일반적으로 더 기술적으로 능숙한 팀에 의해 채택됩니다. 기술적으로 능숙한 팀에게 더 효과적인 기술이 덜 능숙한 팀에게 적합하지 않을 수 있습니다. 우리는 이미 많은 팀이 혼란스러운 단일체를 구축한 것을 보았습니다. 이 혼란이 마이크로서비스에 발생하면 어떤 일이 일어날까요? 이것은 시간이 지남에 따라 관찰될 필요가 있습니다. 나쁜 팀은 항상 나쁜 시스템을 구축할 것입니다 - 이 경우 마이크로서비스가 혼란을 줄이는지 아니면 사태를 악화시키는지 말하기 어렵습니다.

우리가 듣는 합리적인 주장 중 하나는 마이크로서비스 아키텍처로 시작해서는 안 되며, 모놀리식으로 시작해서 모듈화를 유지하고 모놀리식이 문제가 될 때만 분해해야 한다는 것입니다. (이 제안은 이상적이지 않습니다. 왜냐하면 좋은 프로세스 내 인터페이스는 일반적으로 좋은 서비스 인터페이스가 아니기 때문입니다.)

그래서 우리는 조심스럽게 낙관적으로 이것을 씁니다. 지금까지 우리가 본 것으로, 마이크로서비스 스타일은 가치 있는 길일 수 있으며, 탐색할 가치가 있습니다. 우리는 결국 어디에서 끝날지 확신할 수 없지만, 소프트웨어 개발의 도전 중 하나는 현재 가지고 있는 불완전한 정보에 기반하여 결정을 내려야 한다는 것입니다.

## 각주

1: "마이크로서비스"라는 용어는 2011년 5월 베니스 근처에서 소프트웨어 아키텍트 워크숍에서 논의되었습니다. 이는 참가자들이 최근 탐구해온 공통의 아키텍처 스타일을 설명하기 위해 사용되었습니다. 2012년 5월 같은 그룹은 "마이크로서비스"를 가장 적절한 이름으로 결정했습니다. James는 2012년 3월 크라쿠프에서 33rd Degree에서 [Microservices - Java, the Unix Way](http://2012.33degree.org/talk/show/67) 라는 주제로 이러한 아이디어 중 일부를 사례 연구로 제시했으며, Fred George도 [대략 같은 시기](http://www.slideshare.net/fredgeorge/micro-service-architecure). 에 그랬습니다. Netflix의 Adrian Cockcroft는 이 접근 방식을 "세밀한 SOA"로 설명하며 웹 규모에서 스타일을 개척했으며, 이 글에 언급된 많은 다른 사람들 - Joe Walnes, Dan North, Evan Botcher 및 Graham Tackley도 마찬가지였습니다.
-> The term "microservice" was discussed at a workshop of software architects near Venice in May, 2011 to describe what the participants saw as a common architectural style that many of them had been recently exploring. In May 2012, the same group decided on "microservices" as the most appropriate name. James presented some of these ideas as a case study in March 2012 at 33rd Degree in Krakow in [Microservices - Java, the Unix Way](http://2012.33degree.org/talk/show/67) as did Fred George [about the same time](http://www.slideshare.net/fredgeorge/micro-service-architecure). Adrian Cockcroft at Netflix, describing this approach as "fine grained SOA" was pioneering the style at web scale as were many of the others mentioned in this article - Joe Walnes, Dan North, Evan Botcher and Graham Tackley.

2: 용어 "모놀리스(monolith)"는 Unix 커뮤니티에서 이미 오랫동안 사용되어 왔습니다. [The Art of Unix Programming](https://www.amazon.com/gp/product/B003U2T5BA?ie=UTF8&tag=martinfowlerc-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=B003U2T5BA) 에서는 시스템이 너무 커지는 것을 설명하기 위해 등장했습니다.
-> The term monolith has been in use by the Unix community for some time. It appears in [The Art of Unix Programming](https://www.amazon.com/gp/product/B003U2T5BA?ie=UTF8&tag=martinfowlerc-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=B003U2T5BA) to describe systems that get too big.

3: 우리를 포함한 많은 객체 지향 디자이너들은 [Domain-Driven Design](https://www.amazon.com/gp/product/0321125215?ie=UTF8&tag=martinfowlerc-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0321125215) 의미에서 서비스 객체라는 용어를 사용합니다. 이는 엔터티에 연결되지 않은 중요한 프로세스를 수행하는 객체를 위한 것입니다. 이는 이 글에서 사용하는 "서비스"와 다른 개념입니다. 유감스럽게도 서비스라는 용어는 두 가지 의미를 가지고 있으며, 우리는 이 중의성을 받아들여야 합니다.
-> Many object-oriented designers, including ourselves, use the term service object in the [Domain-Driven Design](https://www.amazon.com/gp/product/0321125215?ie=UTF8&tag=martinfowlerc-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0321125215) sense for an object that carries out a significant process that isn't tied to an entity. This is a different concept to how we're using "service" in this article. Sadly the term service has both meanings and we have to live with the polyseme.

4: 우리는 [애플리케이션을 사회적 구성](https://martinfowler.com/bliki/ApplicationBoundary.html) 으로 간주합니다. 이는 코드 베이스, 기능 그룹, 자금의 본체를 함께 묶습니다.
-> We consider [an application to be a social construction](https://martinfowler.com/bliki/ApplicationBoundary.html) that binds together a code base, group of functionality, and body of funding.

5: 원본 논문은 Melvyn Conway의 웹사이트 [여기](http://www.melconway.com/Home/Committees_Paper.html). 에서 찾을 수 있습니다.
-> The original paper can be found on Melvyn Conway's website [here](http://www.melconway.com/Home/Committees_Paper.html).

6: ESB가 ["Egregious Spaghetti Box"](http://www.infoq.com/presentations/soa-without-esb) 의 약자라는 Jim Webber의 발언을 언급하지 않을 수 없습니다.
-> We can't resist mentioning Jim Webber's statement that ESB stands for ["Egregious Spaghetti Box"](http://www.infoq.com/presentations/soa-without-esb).

7: Netflix는 그들의 아키텍처 스타일을 최근까지 세밀한 SOA로 명시적으로 언급했습니다.
-> Netflix makes the link explicit - until recently referring to their architectural style as fine-grained SOA.

8: 극단적인 규모에서, 조직들은 종종 이진 프로토콜로 이동합니다. 예를 들어 - [protobufs](https://code.google.com/p/protobuf/) 등입니다. 이러한 시스템은 여전히 스마트 엔드포인트, 덤브 파이프의 특징을 나타내며, 투명성과 규모 사이의 교환을 선택합니다. 대부분의 웹 속성과 확실히 대다수의 기업은 이러한 교환을 할 필요가 없습니다. 투명성이 큰 승리가 될 수 있습니다.
-> At extremes of scale, organisations often move to binary protocols - [protobufs](https://code.google.com/p/protobuf/) for example. Systems using these still exhibit the characteristic of smart endpoints, dumb pipes - and trade off transparency for scale. Most web properties and certainly the vast majority of enterprises don't need to make this tradeoff - transparency can be a big win.

9: "YAGNI" 또는 "You Aren't Going To Need It"는 [XP 원](http://c2.com/cgi/wiki?YouArentGonnaNeedIt) 이며, 필요할 때까지 기능을 추가하지 말라는 촉구입니다.
-> "YAGNI" or "You Aren't Going To Need It" is an [XP principle](http://c2.com/cgi/wiki?YouArentGonnaNeedIt) and exhortation to not add features until you know you need them.

10: 우리가 모놀리스가 단일 언어라고 주장하는 것은 약간 부정직합니다. 오늘날의 웹에서 시스템을 구축하려면 JavaScript, XHTML, CSS, 선택한 서버 측 언어, SQL 및 ORM 방언을 알아야 합니다. 겨우 단일 언어라고 할 수는 없지만, 우리가 의미하는 바를 알고 있습니다.
->  It's a little disengenuous of us to claim that monoliths are single language - in order to build systems on todays web, you probably need to know JavaScript and XHTML, CSS, your server side language of choice, SQL and an ORM dialect. Hardly single language, but you know what we mean.

11: Adrian Cockcroft는 [이 우수한 프레젠테이션](http://www.slideshare.net/adrianco/flowcon-added-to-for-cmg-keynote-talk-on-how-speed-wins-and-how-netflix-is-doing-continuous-delivery) 에서 "개발자 자가 서비스"와 "개발자가 작성한 것을 실행한다"를 구체적으로 언급했습니다.
->  Adrian Cockcroft specifically mentions "developer self-service" and "Developers run what they wrote"(sic) in [this excellent presentation](http://www.slideshare.net/adrianco/flowcon-added-to-for-cmg-keynote-talk-on-how-speed-wins-and-how-netflix-is-doing-continuous-delivery) delivered at Flowcon in November, 2013.

12: 여기서 우리는 조금 부정직합니다. 분명히 더 복잡한 토폴로지에서 더 많은 서비스를 배포하는 것은 단일 모놀리스를 배포하는 것보다 더 어렵습니다. 다행히 패턴은 이 복잡성을 줄입니다 - 도구에 대한 투자는 여전히 필수입니다.
->  We are being a little disengenuous here. Obviously deploying more services, in more complex topologies is more difficult than deploying a single monolith. Fortunately, patterns reduce this complexity - investment in tooling is still a must though.

13: 사실, Dan North는 이 스타일을 마이크로서비스보다는 _교체 가능한 구성요소 아키텍처_로 언급합니다. 이것이 우리가 선호하는 특성의 일부에 대해 이야기하는 것처럼 보이기 때문에, 우리는 후자를 선호합니다.
-> In fact, Dan North refers to this style as _Replaceable Component Architecture_ rather than microservices. Since this seems to talk to a subset of the characteristics we prefer the latter.

14: Kent Beck은 이를 [구현 패턴](https://www.amazon.com/gp/product/0321413091?ie=UTF8&tag=martinfowlerc-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0321413091) 에서 자신의 디자인 원칙 중 하나로 강조합니다.
-> Kent Beck highlights this as one his design principles in [Implementation Patterns](https://www.amazon.com/gp/product/0321413091?ie=UTF8&tag=martinfowlerc-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0321413091).

15: 그리고 SOA는 이 역사의 뿌리가 거의 아닙니다. SOA 용어가 세기 초에 나타났을 때 "우리는 수년간 이것을 해왔다"고 말하는 사람들을 기억합니다. 한 가지 주장은 이 스타일이 엔터프라이즈 컴퓨팅 초기에 COBOL 프로그램이 데이터 파일을 통해 통신하는 방식의 뿌리를 가지고 있다는 것입니다. 다른 방향으로는, 마이크로서비스가 Erlang 프로그래밍 모델과 같은 것이지만, 엔터프라이즈 애플리케이션 컨텍스트에 적용된 것이라고 주장할 수 있습니다.
-> And SOA is hardly the root of this history. I remember people saying "we've been doing this for years" when the SOA term appeared at the beginning of the century. One argument was that this style sees its roots as the way COBOL programs communicated via data files in the earliest days of enterprise computing. In another direction, one could argue that microservices are the same thing as the Erlang programming model, but applied to an enterprise application context.
