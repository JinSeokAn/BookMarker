# 마이크로서비스로의 전환 개요

모놀리식 애플리케이션을 마이크로서비스 아키텍처로 전환하는 것은 일련의 현대화 과정을 의미하며, 이는 몇 세대에 걸쳐 개발자들이 계속해온 작업과 비슷합니다. 실제로, 전환할 때 우리는 몇 가지 아이디어를 재사용할 수 있습니다.

한 가지 전략은 대규모(big bang)로 코드를 재작성하지 않는 것입니다(마이크로서비스 기반으로 완전히 새로운 애플리케이션을 구축할 때만 재작성하는 방법을 사용할 수 있습니다). 코드 재작성은 좋은 생각처럼 들리지만, 실제로는 많은 위험을 수반하며 결국 실패할 수 있습니다. 마틴 파울러가 말했듯이:

> “대규모 재작성은 대규모 폭발을 보장할 뿐입니다!”

대신, 모놀리식 애플리케이션을 점진적으로 전환하는 전략을 채택해야 합니다. 새로운 마이크로서비스 애플리케이션을 점진적으로 구축하고 기존 모놀리식 애플리케이션과 통합함으로써, 시간이 지남에 따라 모놀리식 애플리케이션의 전체 아키텍처 내에서 비중이 점차 감소하다가 사라지거나 마이크로서비스 아키텍처의 일부가 됩니다. 이 전략은 고속도로에서 속도를 70마일로 제한하면서 차량을 유지하는 것과 같으며, 비록 도전적이지만 재작성의 위험보다는 훨씬 작습니다.

마틴 파울러는 이러한 현대화 전략을 'Strangler' 애플리케이션으로 명명했습니다. 이는 열대 우림의 'Strangler vine'이나 'Strangler fig'에서 유래한 이름으로, 대나무가 정상에 도달하기 위해 큰 나무를 감싸며 자라나고, 시간이 지나면 나무가 죽고 덩굴만 남게 되는 현상에서 착안한 것입니다. 이 애플리케이션도 비슷한 패턴을 사용하여, 전통적인 애플리케이션을 둘러싸며 새로운 마이크로서비스 애플리케이션을 개발하고, 결국 전통적인 애플리케이션이 무대에서 사라지게 합니다.

다른 실행 가능한 전략을 살펴봅시다.

# 전략 1 - 굴착 중단

'Law of Holes'는 자신이 구덩이에 빠졌을 때는 굴착을 멈추어야 한다고 말합니다. 모놀리식 애플리케이션이 관리하기 어려워졌을 때 이는 최상의 조언입니다. 다시 말해, 모놀리식 애플리케이션이 더 커지는 것을 멈춰야 합니다. 즉, 새로운 기능을 개발할 때 기존 모놀리식 애플리케이션에 새 코드를 추가해서는 안 된다는 의미입니다. 최선의 방법은 새 기능을 독립적인 마이크로서비스로 개발하는 것입니다.

![1](./images/Law-of-Holes.png)

마이크로서비스와 모놀리식 애플리케이션을 통합하기 위한 두 가지 주요 모듈이 있습니다. 하나는 요청 라우터로, 들어오는 HTTP 요청을 처리하는 역할을 하며 이전에 언급된 API 게이트웨이와 유사합니다. 라우터는 새로운 기능에 대한 요청을 새롭게 개발된 서비스로 전달하고, 기존의 요청은 모놀리식 애플리케이션으로 다시 보냅니다.

또 다른 모듈은 글루 코드(glue code)로, 마이크로서비스와 모놀리식 애플리케이션을 통합하는 역할을 합니다. 마이크로서비스는 자주 모놀리식 애플리케이션의 데이터에 접근해야 하므로, 글루 코드는 데이터 통합을 담당합니다. 마이크로서비스는 글루 코드를 통해 모놀리식 애플리케이션에서 데이터를 읽고 쓸 수 있습니다.

마이크로서비스가 모놀리식 애플리케이션의 데이터에 접근하는 세 가지 방법은 다음과 같습니다:

- 모놀리식 애플리케이션이 제공하는 원격 API를 통한 접근
- 모놀리식 애플리케이션의 데이터베이스에 직접 접근
- 모놀리식 애플리케이션에서 동기화한 데이터의 복사본을 자체적으로 유지 관리
  
글루 코드는 또한 안티코럽션 레이어(anti-corruption layer)로 불리는데, 이는 글루 코드가 마이크로서비스의 새로운 도메인 모델을 모놀리식 애플리케이션의 전통적인 도메인 모델로부터 오염되지 않도록 보호하기 때문입니다. 글루 코드는 이 두 가지 모델 간의 번역 기능을 제공합니다. 안티코럽션 레이어라는 용어는 에릭 에반스가 저술한 필독서인 _도메인 주도 설계_에서 처음 등장했으며, 이후에 백서로 발전했습니다. 안티코럽션 레이어를 개발하는 것은 그다지 중요하지 않아 보일 수 있지만, 모놀리식 늪에서 벗어나기 위한 필수적인 부분입니다.

새 기능을 경량 마이크로서비스 방식으로 구현하는 것은 여러 장점을 가집니다. 예를 들어, 모놀리식 애플리케이션이 더 이상 관리 불가능하게 커지는 것을 막을 수 있습니다. 마이크로서비스 자체는 독립적으로 개발, 배포 및 확장할 수 있습니다. 마이크로서비스 아키텍처를 채택함으로써 개발자는 다른 경험을 할 수 있습니다.

그러나 이 방법은 모놀리식 애플리케이션 자체의 문제를 해결하지 않습니다. 모놀리식 애플리케이션 자체의 문제를 해결하려면 애플리케이션 내부로 들어가 변경을 수행해야 합니다. 이를 위한 전략을 살펴보겠습니다.


# 전략 2 - 프론트엔드와 백엔드 분리

모놀리식 애플리케이션의 복잡성을 줄이는 전략 중 하나는 프레젠테이션 레이어와 비즈니스 로직, 데이터 액세스 레이어를 분리하는 것입니다. 일반적인 기업용 애플리케이션은 적어도 세 가지 다른 요소로 구성됩니다:

1. 프레젠테이션 레이어 - HTTP 요청을 처리합니다. REST API 요청에 응답하거나 HTML 기반의 그래픽 인터페이스를 제공합니다. 복잡한 사용자 인터페이스 애플리케이션에서 프레젠테이션 레이어는 코드의 중요한 부분을 차지합니다.

2. 비즈니스 로직 레이어 - 애플리케이션의 핵심이 되는 비즈니스 로직을 완성합니다.

3. 데이터 액세스 레이어 - 데이터베이스와 메시지 브로커와 같은 기본 요소에 접근합니다.

프레젠테이션 레이어와 비즈니스 로직 및 데이터 액세스 레이어 사이에는 명확한 분리가 있습니다. 비즈니스 레이어는 비즈니스 로직을 포함하는 여러 가지 측면으로 구성된 굵은 입자(granular) API를 가지고 있습니다. 이 API는 모놀리식 애플리케이션을 두 개의 더 작은 애플리케이션으로 나누는 자연스러운 경계를 제공합니다. 하나는 프레젠테이션 레이어이고, 다른 하나는 비즈니스 로직과 데이터 액세스 로직입니다. 분리된 후, 프레젠테이션 로직 애플리케이션은 비즈니스 로직 애플리케이션을 원격 호출합니다.

이러한 분리는 애플리케이션의 두 부분을 독립적으로 개발, 배포 및 확장할 수 있게 해줍니다. 특히, 프레젠테이션 레이어 개발자들이 사용자 인터페이스에서 빠르게 이터레이션하고 A/B 테스트를 수행할 수 있게 됩니다. 또한, 일부 원격 API는 마이크로서비스에서 호출될 수 있습니다.

그러나 이 전략은 부분적인 해결책일 뿐입니다. 애플리케이션의 두 부분 중 하나 또는 둘 다 여전히 관리하기 어려울 수 있으므로, 남아 있는 모놀리식 아키텍처를 제거하기 위해 세 번째 전략이 필요합니다.


![2](./images/Before-and-after-migration.png)

모놀리식 애플리케이션을 이렇게 분리하는 것에는 두 가지 큰 이점이 있습니다. 
첫 번째는 애플리케이션의 두 부분을 독립적으로 개발, 배포, 확장할 수 있게 되는 것입니다. 
특히, 프레젠테이션 레이어 개발자들이 사용자 인터페이스에서 빠르게 변화를 적용하고 A/B 테스트를 진행할 수 있게 됩니다. 
두 번째 이점은 일부 원격 API가 마이크로서비스에 의해 호출될 수 있다는 것입니다.

그러나 이 전략은 부분적인 해결책일 뿐입니다. 
애플리케이션의 두 부분 중 하나 또는 모두가 여전히 관리하기 어려울 수 있으므로, 
남은 모놀리식 구조를 해결하기 위한 세 번째 전략이 필요합니다. 이는 애플리케이션의 특정 부분을 식별하고 그 부분을 독립적인 마이크로서비스로 추출하는 과정을 포함할 수 있습니다.
이를 통해 점차적으로 모놀리식 애플리케이션의 복잡성을 줄이고 마이크로서비스 기반의 더 유연하고 관리 가능한 시스템으로 전환할 수 있습니다. 이러한 접근 방식은 기존 시스템의 안정성을 유지하면서 점진적으로 아키텍처를 현대화하는 데 도움이 됩니다.


# 전략 3 - 서비스 추출

세 번째 전환 전략은 모놀리식 애플리케이션에서 특정 모듈을 추출하여 독립적인 마이크로서비스로 만드는 것입니다. 
모듈 하나를 마이크로서비스로 추출할 때마다 모놀리식 애플리케이션은 조금 더 간단해집니다. 
충분히 많은 모듈을 전환하면, 모놀리식 애플리케이션 자체는 더 이상 문제가 되지 않으며, 사라지거나 단순해져서 하나의 서비스가 됩니다.


## 어떤 모듈을 마이크로서비스로 전환할 것인가

거대하고 복잡한 모놀리식 애플리케이션은 수십 또는 수백 개의 모듈로 구성되며, 각각이 마이크로서비스로 전환될 후보입니다.
첫 번째로 전환할 모듈을 결정하는 것은 도전적일 수 있으며, 일반적으로 가장 쉽게 추출할 수 있는 모듈부터 시작하는 것이 좋습니다. 
이는 개발자들이 경험을 축적하고 이후 모듈화 작업에 큰 도움이 됩니다.

## 모듈 추출 방법

모듈을 추출하는 첫 번째 단계는 모듈과 모놀리식 애플리케이션 사이의 굵은 입자(granular) 인터페이스를 정의하는 것입니다. 모놀리식 애플리케이션과 마이크로서비스는 서로 데이터가 필요하기 때문에, 이는 사실상 양방향 API와 같습니다. 의존성과 미세 입자(fine-grained) 인터페이스 패턴 사이에서 균형을 잡아야 하기 때문에, 이러한 API를 개발하는 것은 상당한 도전이 될 수 있습니다. 특히 도메인 모델 패턴을 사용하는 비즈니스 로직 레이어에서는 더욱 그러합니다. 이로 인해 종종 코드를 변경하여 의존성 문제를 해결해야 합니다.

굵은 입자 인터페이스를 정의한 후, 해당 모듈을 독립적인 마이크로서비스로 전환할 수 있습니다. 이를 위해, 모놀리식 애플리케이션과 마이크로서비스 간에 정보를 교환하기 위해 프로세스 간 통신(IPC) 메커니즘을 사용하는 API를 작성해야 합니다.

이러한 전환은 모놀리식 애플리케이션의 일부를 독립적으로 개발, 배포 및 확장 가능한 마이크로서비스로 분리함으로써 전체 시스템의 복잡성을 줄이고 유지 관리를 용이하게 하는 데 도움이 됩니다. 마이크로서비스로의 전환 과정은 점진적이고 신중하게 이루어져야 하며, 전체 애플리케이션의 안정성을 유지하면서 아키텍처를 현대화하는 데 중점을 둡니다. 이 과정에서 굵은 입자 인터페이스의 정의 및 IPC를 통한 통신 구현은 중요한 단계로, 성공적인 마이크로서비스 전환을 위한 기반을 마련합니다.

![3](./images/30103116_ZCcM.png)

이 예시에서, Y 모듈을 사용하는 Z 모듈은 추출 가능한 후보 모듈입니다. 이 모듈은 X 모듈에 의해 사용되고 있습니다. 전환의 첫 번째 단계는 굵은 입자 API 세트를 정의하는 것입니다. 첫 번째 인터페이스는 Z 모듈을 활성화하기 위해 X 모듈에 의해 사용되는 내부 인터페이스여야 하며, 두 번째 인터페이스는 Y 모듈을 활성화하기 위해 Z 모듈에 의해 사용되는 외부 인터페이스여야 합니다.

전환의 두 번째 단계는 모듈을 독립적인 서비스로 변환하는 것입니다. 내부 및 외부 인터페이스 모두 IPC(프로세스 간 통신) 메커니즘을 기반으로 하는 코드를 사용합니다. 일반적으로 Z 모듈은 서비스 발견과 같은 전환 과정 중의 문제를 처리하기 위해 마이크로서비스 기반 프레임워크로 통합됩니다.

모듈이 추출되면, 이 서비스는 모놀리식 애플리케이션 및 기타 서비스와 독립적으로 개발, 배포 및 확장할 수 있습니다. 경우에 따라서는 서비스를 처음부터 새로 작성할 수 있으며, 이 경우 서비스와 모놀리식 애플리케이션을 통합하는 API 코드는 두 가지 도메인 모델 사이에서 번역 작업을 수행하는 안티코럽션 레이어가 됩니다. 서비스를 하나씩 추출할 때마다 마이크로서비스 방향으로 한 걸음 더 나아갑니다. 시간이 지남에 따라 모놀리식 애플리케이션은 점점 더 단순해지며, 개발자는 더 많은 독립적인 마이크로서비스를 추가할 수 있게 됩니다. 기존 애플리케이션을 마이크로서비스 아키텍처로 현대화하는 것은 코드를 처음부터 다시 작성하는 것이 아니라, 점진적인 전환을 통해 이루어져야 합니다. 새 기능을 마이크로서비스 방식으로 구현하고, 프레젠테이션 레이어를 비즈니스 및 데이터 액세스 레이어와 분리하며, 기존 모듈을 마이크로서비스로 추출하는 세 가지 전략을 고려할 수 있습니다. 이러한 방식으로 시간이 지남에 따라 마이크로서비스의 수가 증가하고 개발 팀의 유연성과 효율성이 크게 향상됩니다.

